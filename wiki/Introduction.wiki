#summary quick introduction to the library
#labels Featured

= Introduction =

Let start with some examples. Suppose your are building a bookstore and want to represent books and authors. You might have two Java classes similar to (we will discuss the annotations in a minute):

{{{
@Entity
class Book {
  @Value
  private String title;
  @Value
  private String isbn;
  @Value
  private Set<Author> authors;
}

@Entity
class Author {
  @Value
  private String firstName;
  @Value
  private String lastName;
}
}}}

and from an instance of a book, build the JSON object

{{{
{"title":   "Vocation Createurs",
 "isbn":    "2829302680",
 "authors": [{"firstName": "Barbara", "lastName": "Polla"},
             {"firstName": "Pascal",  "lastName": "Perez"}]}
}}}

or vice-versa: you have a JSON representation and wish to create Java instances automatically from it. !JsonMarshaller offers exactly that.

{{{
Book vocationCreateurs = ...;
Marshaller<Book> m = TwoLattes.createMarshaller(Book.class);
JSONObject o = m.marshall(vocationCreateurs);
}}}

and

{{{
JSONObject o = ...;
Marshaller<Book> m = TwoLattes.createMarshaller(Book.class);
Book vocationCreateurs = m.unmarshall(o);
}}}

==Entities==

Entities represent the domain model. They are objects holding data, such as `Book`, `Auhtor`, `User`, or `Account`. On the other hand, an !InpusStream object for instance, represents computation.

To work with the !JsonMarshaller, your entities should provide a no argument constructor. This allows the marshaller to create fresh instances and populate them.

==Annotations==

The !JsonMarshaller uses two annotations to describe entities: `@Entity` and `@Value`.

As we have seen

{{{
@Entity
class Book {
}}}

the `@Entity` annotates a class and informs the marshaller that it is a JSON entity. Again, entities should have a no argument constructor.

The second annotation

{{{
  @Value
  String firstName;
}}}

informs the marshaller that the field should be persisted to JSON. Non annotated fields are considered transient (will not be persisted).
Everything needed is automatically inferred from the bytecode of the Book class!